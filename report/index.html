<!DOCTYPE html>
<html>
  <head>
    <title>Laser Display</title>
    <link rel="stylesheet" href="style.css" />
    <script type="text/javascript" src="refs_nums.js"></script>
    <script type="text/javascript">
      function init() {
          match_figure_references();
      }
    </script>
    <script type="text/javascript" async="true"
            src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
    </script>
  </head>

  <body onload="init()">
    <header>
      <h1 class="page_title">Laser Display</h1>
      <p>Peter Friend, Istvan Burbank, James Cassell</p>
    </header>

    <section>
      <h2>Introduction</h2>
      <p>
        An image projector that draws using colored lasers controlled by a PIC32.
      </p>

      <p>
        We use several colored lasers to generate a single pixel.
        A system of mirrors deflects the lasers to control where they shine.
        A vertical mirror controls the height of the projected laser.
        A spinning mirror assembly causes the laser to &quot;scan&quot; horizontally.
        The spinning mirrors always spin at constant speed while the software outputs pixels.
        The vertical mirror changes position at the end of every row.
      </p>
    </section>

    <section>
      <h2>High-level design</h2>
      <p>
        The horizontal mirrors are four mirrors on the sides of a spinning cube.
        A single row of the output display is shown in the time it takes for one of the four spinning mirrors to move through part of it's arc.
        Each rotation of the mirror assembly is thus four rows.
        The rotation of the mirror assembly is used to control the beginning of a row via a phototransistor and Change Notification interrupt.
        DMA outputs the entire row into our diode control circuits, with a timer controlling the time between pixels.
        The interrupt for the end of the DMA block transfer is used to configure the DMA and the vertical mirror for the next row.
      </p>

      <h3>Background math</h3>
      During the planning part of the project, it was helpful to get an idea of about what our display would look like, based on the parts that were available to us.
      <h4>Angled Mirror Range</h4>
      <p>
        First item we wanted to determine was what range our angled mirror would need to support.
        To do this, we are able to find the max and minumum angle as a function of distance, height, and mirror size.
        <div class="figure" id="fig_reflectionAngle">
          <img src="./images/reflectionAngle.svg" />
          <div class="caption">Geometry of reflection off vertical mirror</div>
        </div>
        By taking the tangent of the right triangle that the angled mirror makes with our X-axis, we can calculate the range of angles the mirror needs to support.
        $$\tan{\theta_{min}} = a / b \rightarrow \arctan{(b / a)} = \theta_{min}$$
        $$\tan{\theta_{max}} = (b + mirror\_size) / a = (b + 3) / a \rightarrow \theta_{max} = arctan{(b + 3) / a}$$
        This allowed us to an idea of what range of angles our mirror would need to produce with respect to the mirror.
      </p>
      <h4>Row Arc</h4>
      <p>
        One concern that we had with using mirrors to scan rows, was the potential arcing of rows due to the different distances the laser has to travel to hit the mirror.
        By using the figure below, we can use some trigonometry to determine how big the arc will be at the largest point from the smallest point of the arc.
        <div class="figure" id="fig_scanningReflection">
          <img src="./images/scanningReflection.svg" />
          <div class="caption">Geometry of arc in a single row</div>
        </div>
        Due to how the circle spins the mirror, the largest point in distance when scanning is between the start and midpoint of the mirror.
        This creates a difference of about half the mirror size in the distance along the X-axis it takes for the laser to hit the mirror.
        By using some trig, we can find that the angle at which the laser comes from the tilted mirror, impacts the distance between the two positions.
        Here we can say that $$p_0$$ is the first reflection of the laser from the mirror on the screen, and $$p_1$$ is the second.
        Due to the <a href="http://farside.ph.utexas.edu/teaching/302l/lectures/node127.html"> Law of Reflectivity</a> the angle to the moving mirror is the same as the angle to the screen.
        Doing this, with theta being the angle between the tilting and rotating mirror:
        $$\theta = \tan{b / a} \rightarrow \tan{b / a} = \tan{p_0 / L} \rightarrow p_0 = b * L / a$$
        To find the top position it is a little bit trickier.
        We know that up until point a, that the laser is in effectively in the same place at the same angle.
        One beam reflects, but the other continues to hit the further mirror.
        We find that it gains a position change in the Y-axis of $$\Delta h = mirror\_size/2 * \tan{\theta} = mirror\_size / 2 * b / a$$
        Before the beam returns to point a, it has effectively gained two delta h's in height.
        With that in mind, we can then use the same method as before, since the angle is still the same as with p_0, therefore:
        $$p_1 = mirror\_size * b / a + b * L / a$$
        Then to find the difference between the smallest and tallest point of the arc we find
        $$\Delta y = p_1 - p_0 = mirror\_size * b /a + b * L / a - b * L / a = mirror\_size * b / a$$
        Finding this, we realized that as long as our mirror array is at least three times as far away from the tilted mirror as it is higher, we should see minimal arc when scanning across rows.
      </p>
      <h4>Pixel Size</h4>
      <p>
        The pixel size of the display is directly tied to the beamwidth of the laser.
        Due to the nature of the lasers that we used in our setup, we did not observe many nonlinear effects in terms of beam divergance.
        Therefore when we measured how fast the beam diverged, we assumed that it diverged linearly.
        We describe beamwidth as a funciton of distance from the mirror.
        The pixel size that you are able to have, is the size of the beamwidth at a given distance, as we cannot have mulitple beams overlapping, causing aliasing of the output.
      </p>
      <h4>RPM Considerations</h4>
      <p>
        After finding the size of each pixel, it was important to determine how many pixels that we could display at a given speed of our mirror array.
        As seen in the figure below, the mirror array must turn by $$\theta = arctan{(beamwidth / D)}$$ to draw nonoverlapping pixels.
        <div class="figure" id="fig_pixelSize">
          <img src="./images/pixelSize.svg" />
          <div class="caption">Geometry of pixel sizes and overlaps</div>
        </div>
        That gives us the amount of radians the mirror array must turn in order to produce a single pixel.
        To find the RPM required to display a certain number of pixels, we found that:
        $$RPM = 2\pi (radians)/ 1 (Hz) * 1 (S) / Num\_pixs * \arctan{(beamwidth / D)} * 60 (RPM) / 1 (Hz)$$
        Where $$Num\_pixs = DISPLAY\_HEIGHT * DISPLAY\_WIDTH * FPS$$
        This comes from having radians per pixel, multiplied by pixels per second, then Hertz per radian, and then RPM per Hertz to get the final RPM.
        After calculating that our fan speed which spun our mirror array was 3600, we assumed we would be able to have a 50x50 pixel array.
      </p>
      <h3>Logical structure</h3>

      <h3>Tradeoffs</h3>

      <h3>Intellectual property</h3>

    </section>

    <section>
      <h2>Hardware Design</h2>

    </section>

    <section>
      <h2>Software Design</h2>

      <h3>Framebuffer</h3>
      <p>
        The rows to project are stored in a two-dimensional array of C structs.
        This struct uses bitfields, implementation-specific behavior, and a "bit packing" pragma to ensure that each struct fits in exactly a byte.
        Thus a single byte can  be directly copied into the PORTB register to output the bits.
        This allows the DMA to transfer draw pixels without software intervention.
        An implementation-defined &quot;struct punning&quot; technique is used to convert these bit-packed structs into a numeric type when they must be written to the port without DMA.
      </p>

      <h3>Projector</h3>
      <p>
        Our projector implementation makes heavy use of hardware timing.
        That is, the projector code consists of several event-driven actions which are triggered by various hardware events.
      </p>
      <p>
        DMA is used to output pixels to the lasers.
        When a horizontal scan line starts, DMA is configured to output the entire row, one pixel per period of timer A.
        Timer A is free running, and its period determines the aspect ratio of the pixels.
        The DMA transfer of the row is enabled by a Change Notification ISR which runs when the optical transistor is triggered.
        We configured the Change Notification via registers directly because our version of plib is missing the macros.
        Because this PIC32 cannot distinguish between rising and falling edges when triggering the Change Notification ISR, we simply check the value of the pin in software.
        Thus, effectively, the rising edge of the optical transistor triggers the start of a row being output.
        Because the optical transistor is driven by the spinning mirror carousel, the timing of the rows is too so spinning the carousel faster would result in faster output of rows.
      </p>

      <p>
        When a row finishes the DMA triggers an interrupt that increments the Y-axis mirror's position.
        The reason it is done immediately at the end of a line is to ensure the mirror has time to settle into its new position before the start of the next row.
        The mirror is incremented linearly on each row until it reaches the bottom of the frame then it wraps around again to the top.
        Because the increment is triggered by the DMA which is triggered the spinning carousel, spinning the carousel faster would cause the Y-axis mirror's scan rate to increase.
      </p>
      <p>
        The last two paragraphs made claims about the timing of the projector with respect to the carousel.
        In fact, spinning the carousel faster would increase the frame rate without any software changes.
        As the software stands now, the aspect ratio would change but that could be configured out (as the mirror spins faster the rows would get wider).
        The aspect ratio is determined by the period of the timer that triggers cell transfers in the DMA.
      </p>

      <h4>Failed attempt to use one fewer ISR</h4>
      <p>
        An earlier design attempted to use the gated mode of Timer1 to control the DMA and avoid the Change Notification ISR.
        The idea was that each timer period would start a cell transfer, but the timer would only run when a row had to be output.
        The edge caused by the phototransistor circuit was used to asynchronously set an external flip-flop high and the flip-flop output was used as the gate signal.
        The flip-flop would be asynchronously set low in the end of row ISR before the DMA was configured for the next row.
        This would have meant that an ISR was not required at the beginning of the row, only at the end.
        We abandoned this because the non-obvious but documented behavior of gated timers is to generate an interrupt when the gate input goes low and deactivates the timer, rather than on period match.
        This caused the DMA cell transfers to never fire.
      </p>

      <h3>Rendering library</h3>
      <p>
        We ported the TFT drawing library to be backed by our framebuffer rather than by the TFT.
        Due to the simplicity of the framebuffer interface, only rendering_drawPixel in the ported library had to be aware of the framebuffer.
        However, a number of functions in the interface to the original TFT library were written in a way that was tied to the TFT hardware, presumably for efficiency reasons.
        We rewrote these functions in terms of rendering_drawPixel to minimize dependence between the projector and the rendering library.
        This payed off when slightly changing the projector interface midway through the project required minimal changes to the rendering library.
        Additionally, the color representation of the original TFT library had to be replaced with our color struct, requiring very minor changes throughout the entire library.
        We added morse code drawing functions to the rendering library as a demonstration.
        All of the graphics in the demo are drawn using this library.
      </p>

      <p>

    </section>

    <section>
      <h2>Results</h2>

    </section>

    <section>
      <h2>Conclusions</h2>

    </section>

    <section>
      <h2>Appendix A</h2>
      <p>
        The group approves this report for inclusion on the course website.
      </p>
    </section>

    <section>
      <h2>Appendix: Code listing</h2>

    </section>

    <section>
      <h2>Appendix: Schematics</h2>

    </section>

    <section>
      <h2>Appendix: Cost and parts list</h2>

    </section>

    <section>
      <h2>Appendix: Work division</h2>

    </section>

    <section>
      <h2>Appendix: References</h2>
      <h3>Data sheets</h3>

      <h3>Vendor sites</h3>

      <h3>Borrowed designs</h3>

      <h3>Background</h3>

    </section>
  </body>
</html>
